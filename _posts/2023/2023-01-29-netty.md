---
layout: post
title: "netty-初探"
date: 2023-01-29 10:10:00 +0800
categories: tech
---
## netty 简介

Netty是一个高性能、高扩展性的异步事件驱动的网络应用程序框架，它极大的简化了NIO开发的过程，能够快速地开发稳定高性能的面向协议的服务端和客户端。这里讲解如何创建一个简单的netty服务器。

## 示例代码

如下是netty服务器的示例代码。这个服务器对8080端口进行监听，接收客户端连接请求并处理客户端消息。接收到客户端消息后，服务器将消息打印后将原消息再发送给客户端。

```
public class EchoServer {
    public static void main(String[] args) throws Exception {
        EventLoopGroup bossGroup = new NioEventLoopGroup(); // (1)
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ServerBootstrap b = new ServerBootstrap(); // (2)
            b.group(bossGroup, workerGroup)
                    .channel(NioServerSocketChannel.class) // (3)
                    .childHandler(new ChannelInitializer<SocketChannel>() { // (4)
                        @Override
                        public void initChannel(SocketChannel ch) throws Exception {
                            ch.pipeline().addLast(new EchoHandler());
                        }
                    })
                    .option(ChannelOption.SO_BACKLOG, 128)          // (5)
                    .childOption(ChannelOption.SO_KEEPALIVE, true); // (6)

            // Bind and start to accept incoming connections.
            ChannelFuture f = b.bind(8080).sync(); // (7)

            // Wait until the server socket is closed.
            // In this example, this does not happen, but you can do that to gracefully
            // shut down your server.
            f.channel().closeFuture().sync();
        } finally {
            workerGroup.shutdownGracefully();
            bossGroup.shutdownGracefully();
        }
    }
}

public class EchoHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) {
        System.out.println("receive msg:" + ((ByteBuf)msg).toString(Charset.defaultCharset()));
        ctx.write(msg); // (1)
        ctx.flush(); // (2)
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        // Close the connection when an exception is raised.
        cause.printStackTrace();
        ctx.close();
    }
}
```

如下是测试客户端代码，连接服务端后，发送一个hello字符串消息，然后等待接收服务端消息，再将消息打印到控制台。

```
public class TestClient {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket("127.0.0.1", 8080);
        OutputStream os = socket.getOutputStream();
        os.write("hello".getBytes());
        InputStream is = socket.getInputStream();
        byte[] buf = new byte[1024];
        int read = is.read(buf);
        System.out.println(new String(buf, 0, read));
        socket.close();
    }
}
```

## 服务测试

首先启动netty服务器，然后再启动测试客户端。

客户端控制台信息
![](https://raw.githubusercontent.com/xiejinjie/xiejinjie.github.io/gh-pages/assets/img/20221205114814.png)

服务端控制台信息
![](https://raw.githubusercontent.com/xiejinjie/xiejinjie.github.io/gh-pages/assets/img/20221205114910.png)

## 流程讲解

netty服务器创建的整个流程如下图所示。

![img](https://raw.githubusercontent.com/xiejinjie/xiejinjie.github.io/gh-pages/assets/img/20221205112935.png)

上面可以看出创建一个netty服务器是非常简单的，需要以下流程

1. 创建两个NioEventLoopGroup实例。NioEventLoopGroup是一个线程组，它包含了一组NIO线程，专门用于网络事件的处理。这里创建两个的原因是一个用户服务端接收客户端连接，另一个用于SocketChannel的网络读写。
2. 创建ServerBootstrap对象，它是NIO服务端的启动类。
3. 设置创建的Channel为NioServerSocketChannel。它的功能对应于NIO类库中的ServerSocketChannel
4. 设置Channel的处理类。绑定I/O事件处理类EchoHandler，用于处理网络I/O事件。
5. 配置ServerChannel参数，这里配置的是NioServerSocketChannel。
6. 配置Channel参数，这里配置的是NioSocketChannel。
7. 调用bind()绑定端口，调用sync()等待绑定完成

## 参考资料

- netty user guide
  [https://netty.io/wiki/user-guide-for-4.x.html](https://netty.io/wiki/user-guide-for-4.x.html)
- netty权威指南
